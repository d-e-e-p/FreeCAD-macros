#!/usr/bin/python
#####################################
# Copyright (c) deep@tensorfield.ag 2022
# Licensed under LGPL v2
#
# This FreeCAD macro dumps out separate STEP files of all parts at a
# selected hierarchy level from top. A common use case would be to
# use this macro to extract 3d models of all components placed on a pcb
#
# THe hierarchy of document is displayed at a interactive listbox,
# with the levels to be output highlighed with yellow background.
#
# Version history :
# *1.0: beta release
#
#####################################

# -*- coding: utf-8 -*-

__Name__ = 'Export Component Step'
__Comment__ = 'Export 3d STEP files of objects at selected hierarchy level'
__Author__ = 'deep@tensorfield.ag'
__Version__ = '1.0'
__Date__ = '2022-12-13'
__License__ = 'LGPL v2'
__Web__ = 'https://www.freecadweb.org/wiki/Macro_ExportComponentStep'
__Wiki__ = 'https://www.freecadweb.org/wiki/Macro_ExportComponentStep'
__Icon__ = ''
__Help__ = 'Select level & output dir, then click generate to dump STEP files'
__Status__ = 'Beta'
__Requires__ = 'FreeCAD >= 0.17'
__Communication__ = 'https://forum.freecadweb.org/viewtopic.php?tbd'
__Files__ = ''

import os
import tempfile
from collections import defaultdict

import FreeCAD as App
import FreeCADGui as Gui

from PySide import QtGui, QtCore
from PySide.QtGui import QTreeWidget, QTreeWidgetItem
from PySide.QtGui import QHeaderView, QTreeWidgetItemIterator


class Utils:
    """
    General helper functions
    """
    def getInitialOutputDir(self):
        """
        assume output dir is where the document was loaded, else random tmp dir
        TODO: figure out why tempfile ignores env(TMPDIR)
        """
        doc = App.ActiveDocument
        dir = os.path.dirname(doc.FileName)
        if not dir:
            dir = tempfile.TemporaryDirectory().name
        return dir

    def getTopPartsInDocument(self):
        """
        instead of using selection from user Gui.Selection.getSelection()
        just locate top objects in open document and walk down from there
        """
        objs = App.ActiveDocument.RootObjects
        obj_names = [obj.Label for obj in objs]
        print(f' top model : {obj_names}')
        return objs

    def roundLen(self, num):
        """
        need to deal with special case of +- inf, eg on Datum Planes
        """
        for val in ["inf", "-inf"]:
            if num == float(val):
                return val

        large_val = 1e100
        if num > large_val:
            return "inf"
        if num < -large_val:
            return "-inf"

        return str(round(num))

    def findFaces(self, selectionObject):
        """
        from TrimFace.py in
            https://www.programcreek.com/python/example/103512/Part.Face
        """
        res = []
        for obj in selectionObject:
            if hasattr(obj, "HasSubObjects") and obj.HasSubObjects:
                i = 0
                for subobj in obj.SubObjects:
                    if issubclass(type(subobj), App.Part.Face):
                        f = (obj.Object, [obj.SubElementNames[i]])
                        p = obj.PickedPoints[i]
                        u, v = subobj.Surface.parameter(p)
                        res.append((f, App.Vector(u, v, 0)))
                    i += 1
        return (res)


class Tree(QTreeWidget):
    """
    wrapper for QTreeWidget with functions to populate and markup elements
    """
    def __init__(self):
        super(Tree, self).__init__()
        self.objects_to_dump = []    # list of objects to save as STEP
        self.cols = {                  # order of columns in tree
            'Label': 0, 'Type': 1, 'Len': 2, 'XLen': 3, 'YLen': 4, 'ZLen': 5,
            'level': 6, 'obj': 7}      # undisplayed data colunms
        self.column_count = len(self.cols)
        self.max_level = 0           # max levels of hier in document
        self.selected_level = "2"    # hier level to dump
        self.initial_open_nodes = 30  # open tree nodes on startup
        self.nodes_to_prune = []     # leafs of tree with no shape
        self.utils = Utils()
        # ok, time to do stuff...
        self.setupTreeGui()
        self.populateTree()

    def setupTreeGui(self):
        self.setColumnCount(self.column_count)
        # ["Label", "Type", "Len", "XLen", "YLen", "ZLen"])
        self.setHeaderLabels(list(self.cols.keys())[:6])
        self.setColumnHidden(self.cols['obj'], True)   # hide data
        self.setColumnHidden(self.cols['level'], True)
        self.setSortingEnabled(True)

        header = self.header()
        header.setSectionResizeMode(QHeaderView.ResizeToContents)
        header.setStretchLastSection(False)
        header.setSectionResizeMode(self.cols['Label'], QHeaderView.Stretch)
        self.resizeColumnToContents(self.cols['Label'])
        self.selectionModel().selectionChanged.connect(self.treeSelection)

        self.setMinimumWidth(Gui.getMainWindow().width() / 2)
        self.setMinimumHeight(Gui.getMainWindow().height() / 2)

    def highlightObjAndFaces(self, objs):
        Gui.Selection.clearSelection()
        for obj in objs:
            Gui.Selection.addSelection(obj)
        faces = self.utils.findFaces(objs)
        if faces:
            Gui.Selection.addSelection(faces)
        Gui.runCommand('Std_ShowSelection', 0)

    def treeSelection(self, selected, deselected):
        objs = []
        for node in self.selectedItems():
            obj = node.data(self.cols['obj'], QtCore.Qt.UserRole)
            objs.append(obj)
        self.highlightObjAndFaces(objs)

    def populateTree(self):
        """
        initial creation of hier nodes
        """

        objs = self.utils.getTopPartsInDocument()

        self.clear()
        root = self.invisibleRootItem()
        self.addChildren(objs, parent=root, level=0)

        # remove leaf nodes without shapes
        self.pruneNonShapeNodes()

        # determine max level of hier after pruning
        self.determineMaxLevel()

        # open some top level tree elements
        self.expandTreeToSensibleLevel()

    def addChildren(self, objs=None, parent=None, level=0):
        """
        add node to tree including name, object type and XYZ lengths

        """
        #  0      1   2   3    4    5     6   7
        # Label Type Len XLen YLen Zlen level obj
        cols = self.cols

        for obj in objs:
            node = QTreeWidgetItem(parent)
            node.setData(cols['obj'], QtCore.Qt.UserRole, obj)
            node.setData(cols['level'], QtCore.Qt.UserRole, level)
            node.setText(cols['Label'], obj.Label)
            # <class 'Sketcher.SketchObject'> -> Sketcher.SketchObject
            typ = str(type(obj))
            typ = typ.replace("<class '", "")
            typ = typ.replace("'>", "")
            node.setText(cols['Type'], typ)

            if hasattr(obj, "Length"):
                node.setText(cols['Len'], str(obj.Length.Value))
                node.setTextAlignment(cols['Len'], QtCore.Qt.AlignRight)

            # if isinstance(obj, App.Part):
            if hasattr(obj, "Shape"):
                bbox = obj.Shape.BoundBox
                node.setText(cols['XLen'], self.utils.roundLen(bbox.XLength))
                node.setText(cols['YLen'], self.utils.roundLen(bbox.YLength))
                node.setText(cols['ZLen'], self.utils.roundLen(bbox.ZLength))

                node.setTextAlignment(cols['XLen'], QtCore.Qt.AlignRight)
                node.setTextAlignment(cols['YLen'], QtCore.Qt.AlignRight)
                node.setTextAlignment(cols['ZLen'], QtCore.Qt.AlignRight)

            # walk down freecad obj children list
            children = obj.ViewObject.claimChildren()
            self.addChildren(children, parent=node, level=level + 1)

    def iterateOverTree(self, callback, param=None):
        """
        https://stackoverflow.com/questions/31434725/iteration-of-a-qtreewidget
        """
        iterator = QTreeWidgetItemIterator(self)
        while iterator.value():
            node = iterator.value()
            callback(node, param)
            iterator += 1

    def pruneNonShapeNodes(self):
        """
        keep running until no leaf node without shape remains
        """
        self.nodes_to_prune = []
        self.iterateOverTree(self.cbSelectNonShapeNode)
        if self.nodes_to_prune:
            for node in self.nodes_to_prune:
                parent = node.parent()
                parent.removeChild(node)
            self.pruneNonShapeNodes()   # run again to cleanup dangling parent

    def cbSelectNonShapeNode(self, node, param):
        """
        tree iteration callback for making a list of leaf nodes without shapes
        """
        if node.childCount() > 0:
            return

        level = node.data(self.cols['level'], QtCore.Qt.UserRole)
        if level < 2:
            return

        obj = node.data(self.cols['obj'], QtCore.Qt.UserRole)
        if hasattr(obj, "Shape"):
            return

        self.nodes_to_prune.append(node)

    def determineMaxLevel(self):
        self.max_level = 0
        self.iterateOverTree(self.cbDetermineMaxLevel)

    def cbDetermineMaxLevel(self, node, param):
        """
        tree iteration callback for determining max level
        """
        level = node.data(self.cols['level'], QtCore.Qt.UserRole)
        if level > self.max_level:
            self.max_level = level

    def expandTreeToSensibleLevel(self):
        # expand to some level initially
        elements_per_level = defaultdict(list)
        iterator = QTreeWidgetItemIterator(self)
        while iterator.value():
            node = iterator.value()
            level = node.data(self.cols['level'], QtCore.Qt.UserRole)
            elements_per_level[level].append(node)
            iterator += 1

        # expand until counter exhausted
        expand_counter = self.initial_open_nodes
        for level in sorted(elements_per_level.keys()):
            for node in elements_per_level[level]:
                node.setExpanded(True)
                expand_counter -= node.childCount()
                if expand_counter < 0:
                    return

    def updateSelectedLevel(self):
        self.objects_to_dump = []
        self.iterateOverTree(self.cbSelectNodesBySelectedLevel)
        self.highlightObjAndFaces(self.objects_to_dump)

    def highlightNode(self, node):
        sel_bgcolor = "yellow"
        for i in range(self.column_count):
            node.setBackgroundColor(i, QtGui.QColor(sel_bgcolor))

    def unhighlightNode(self, node):
        for i in range(self.column_count):
            node.setData(i, QtCore.Qt.BackgroundRole, None)

    def cbSelectNodesBySelectedLevel(self, node, param):
        """
        tree iteration callback collecting list of STEP objects to dump
        """
        self.unhighlightNode(node)
        if self.selected_level:
            # "ALL" is the only non-int string allowed in g_selected_level
            level = node.data(self.cols['level'], QtCore.Qt.UserRole)
            if (self.selected_level == "ALL") or \
               (int(self.selected_level) == level):
                obj = node.data(self.cols['obj'], QtCore.Qt.UserRole)
                if hasattr(obj, "Shape"):
                    self.highlightNode(node)
                    self.objects_to_dump.append(obj)


class ExportComponentStep:
    """
    setupGui is main entry point that creates tree and entry widgets
    """

    def __init__(self):
        # output dir for step
        self.utils = Utils()
        self.selected_directory = self.utils.getInitialOutputDir()
        self.gui = {}                # store gui widgets for callbacks

    def exportSTEP(self):
        gui_tree = self.gui["gui_tree"]
        for obj in gui_tree.objects_to_dump:
            filename = os.path.join(
                self.selected_directory, obj.Label + ".step")
            filename = os.path.normpath(filename)
            print(f'exporting {obj.FullName} to {filename}')
            obj.Shape.exportStep(filename)

    def onDirDialogPopup(self):
        """Called selecting dir"""
        gui_txt_dir = self.gui["gui_txt_dir"]
        self.selected_directory = QtGui.QFileDialog.getExistingDirectory()
        gui_txt_dir.setText(self.selected_directory)

    def onDirLineEdited(self):
        """ selected level changed """
        gui_txt_dir = self.gui["gui_txt_dir"]
        self.selected_directory = str(gui_txt_dir.text())

    def onLevelChanged(self):
        """ selected level changed """
        gui_box_level = self.gui["gui_box_level"]
        gui_tree = self.gui["gui_tree"]
        current_selected_level = gui_box_level.currentText()
        if gui_tree.selected_level != current_selected_level:
            gui_tree.selected_level = current_selected_level
            # highlight levels to be output
            gui_tree.updateSelectedLevel()

            # update button text with number of files to generate
            num = len(gui_tree.objects_to_dump)
            gui_btn_run = self.gui["gui_btn_run"]
            gui_btn_run.setText(f'Generate {num} STEP files')

    def onGenerate(self):
        """Called when generating step files"""
        gui_txt_dir = self.gui["gui_txt_dir"]
        self.selected_directory = str(gui_txt_dir.text())
        if not os.path.isdir(self.selected_directory):
            msg = f'ERROR: dir does not exist - {self.selected_directory}'
            print(msg)
            App.Console.PrintError(msg + "\n")
            return
        self.exportSTEP()

    def pretendLevelChanged(self):
        """Updates hier listbox tree"""
        # force level changed update callback
        gui_tree = self.gui["gui_tree"]
        gui_tree.selected_level = -1
        self.onLevelChanged()

    def setButtonStyle(self, btns):
        """
        make all buttons look the same

        """
        stylesheet = """
        QPushButton {
            background-color: rgb(220, 225, 225);
            border: 2px outset rgb(150, 155, 155);
            border-radius: 5px;
            min-width: 80px;
            padding: 5px;
        }
        QPushButton:pressed {
            background-color: rgb(195, 200, 200);
            border: 2px inset  rgb(150, 155, 155);
        }
        QPushButton:hover {
            background-color:rgb(240, 240, 240)
        }
        QPushButton:checked{
            background-color: rgb(195, 200, 200);
            border: 2px inset  rgb(150, 155, 155);
        }
        """

        for btn in btns:
            btn.setStyleSheet(stylesheet)
            # https://stackoverflow.com/questions/56478207/why-is-the-first-button-blue-in-color-when-i-run-the-pyqt5-program
            btn.setFocusPolicy(QtCore.Qt.NoFocus)

    def setupGui(self):
        """
        first setup tree to determine depth and other stats
        then create top gui elements to prompt for output dir
        and number of levels to export
        """
        gui_tree = Tree()
        self.gui["gui_tree"] = gui_tree

        # Build UI and show
        gui_dlg = QtGui.QDialog(Gui.getMainWindow(), QtCore.Qt.Tool)

        gui_box_level = QtGui.QComboBox(gui_dlg)
        self.gui["gui_box_level"] = gui_box_level
        gui_box_level.addItems([str(e) for e in range(gui_tree.max_level)])
        gui_box_level.addItem("ALL")

        index = 2 if (gui_tree.max_level > 2) else gui_tree.max_level
        gui_box_level.setCurrentIndex(index)
        gui_box_level.currentTextChanged.connect(self.onLevelChanged)

        # editable line to hold target dir
        gui_txt_dir = QtGui.QLineEdit(self.selected_directory, gui_dlg)
        self.gui["gui_txt_dir"] = gui_txt_dir
        # gui_txt_dir.returnPressed.connect(self.onDirLineEdited)

        gui_btn_dir = QtGui.QPushButton("Select Output Dir", gui_dlg)
        gui_btn_dir.clicked.connect(self.onDirDialogPopup)
        self.gui["gui_btn_dir"] = gui_btn_dir

        gen_layout = QtGui.QHBoxLayout()
        gen_layout.addWidget(gui_btn_dir)
        gen_layout.addWidget(gui_txt_dir)
        gen_layout.addWidget(QtGui.QLabel("Level : "))
        gen_layout.addWidget(gui_box_level)

        button_box = QtGui.QDialogButtonBox()

        gui_btn_run = button_box.addButton(
            "Generate STEP", QtGui.QDialogButtonBox.AcceptRole)
        self.gui["gui_btn_run"] = gui_btn_run
        gui_btn_close = button_box.addButton(
            "Close", QtGui.QDialogButtonBox.RejectRole)

        gui_btn_expand = button_box.addButton(
            "Expand Tree", QtGui.QDialogButtonBox.ApplyRole)
        gui_btn_collapse = button_box.addButton(
            "Collapse Tree", QtGui.QDialogButtonBox.ApplyRole)

        gui_btn_expand.clicked.connect(gui_tree.expandAll)
        gui_btn_collapse.clicked.connect(gui_tree.collapseAll)

        button_box.accepted.connect(self.onGenerate)
        button_box.rejected.connect(gui_dlg.reject)

        dlg_layout = QtGui.QVBoxLayout(gui_dlg)
        dlg_layout.insertLayout(0, gen_layout)
        dlg_layout.addWidget(gui_tree)
        dlg_layout.addWidget(button_box)
        # dlg_layout.addWidget(close_dlg_but)

        # set all button styles the same
        self.setButtonStyle(
            [gui_btn_dir,
             gui_btn_expand, gui_btn_collapse, gui_btn_close, gui_btn_run, ])

        self.pretendLevelChanged()
        gui_tree.show()
        gui_dlg.exec_()


def main():
    """

    """
    if not App.GuiUp:
        print("rerun when gui is up...")
        return

    if not App.ActiveDocument:
        print("""
        There is no opened document.
        Please open a doc or import a STEP file before running this macro.
        """)
        return

    e = ExportComponentStep()
    e.setupGui()


main()
